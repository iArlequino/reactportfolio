{"ast":null,"code":"import { useContext } from 'react';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { resolveVariantFromProps } from '../../render/utils/resolve-variants.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { isControllingVariants, isVariantNode } from '../../render/utils/is-controlling-variants.mjs';\nimport { getWillChangeName } from '../../value/use-will-change/get-will-change-name.mjs';\n\nfunction makeState(_ref, props, context, presenceContext, isStatic) {\n  let {\n    applyWillChange = false,\n    scrapeMotionValuesFromProps,\n    createRenderState,\n    onMount\n  } = _ref;\n  const state = {\n    latestValues: makeLatestValues(props, context, presenceContext, isStatic ? false : applyWillChange, scrapeMotionValuesFromProps),\n    renderState: createRenderState()\n  };\n\n  if (onMount) {\n    state.mount = instance => onMount(props, instance, state);\n  }\n\n  return state;\n}\n\nconst makeUseVisualState = config => (props, isStatic) => {\n  const context = useContext(MotionContext);\n  const presenceContext = useContext(PresenceContext);\n\n  const make = () => makeState(config, props, context, presenceContext, isStatic);\n\n  return isStatic ? make() : useConstant(make);\n};\n\nfunction forEachDefinition(props, definition, callback) {\n  const list = Array.isArray(definition) ? definition : [definition];\n\n  for (let i = 0; i < list.length; i++) {\n    const resolved = resolveVariantFromProps(props, list[i]);\n\n    if (resolved) {\n      const {\n        transitionEnd,\n        transition,\n        ...target\n      } = resolved;\n      callback(target, transitionEnd);\n    }\n  }\n}\n\nfunction makeLatestValues(props, context, presenceContext, shouldApplyWillChange, scrapeMotionValues) {\n  var _a;\n\n  const values = {};\n  const willChange = new Set();\n  const applyWillChange = shouldApplyWillChange && ((_a = props.style) === null || _a === void 0 ? void 0 : _a.willChange) === undefined;\n  const motionValues = scrapeMotionValues(props, {});\n\n  for (const key in motionValues) {\n    values[key] = resolveMotionValue(motionValues[key]);\n  }\n\n  let {\n    initial,\n    animate\n  } = props;\n  const isControllingVariants$1 = isControllingVariants(props);\n  const isVariantNode$1 = isVariantNode(props);\n\n  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {\n    if (initial === undefined) initial = context.initial;\n    if (animate === undefined) animate = context.animate;\n  }\n\n  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;\n  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n  const variantToSet = isInitialAnimationBlocked ? animate : initial;\n\n  if (variantToSet && typeof variantToSet !== \"boolean\" && !isAnimationControls(variantToSet)) {\n    forEachDefinition(props, variantToSet, (target, transitionEnd) => {\n      for (const key in target) {\n        let valueTarget = target[key];\n\n        if (Array.isArray(valueTarget)) {\n          /**\n           * Take final keyframe if the initial animation is blocked because\n           * we want to initialise at the end of that blocked animation.\n           */\n          const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;\n          valueTarget = valueTarget[index];\n        }\n\n        if (valueTarget !== null) {\n          values[key] = valueTarget;\n        }\n      }\n\n      for (const key in transitionEnd) {\n        values[key] = transitionEnd[key];\n      }\n    });\n  } // Add animating values to will-change\n\n\n  if (applyWillChange) {\n    if (animate && initial !== false && !isAnimationControls(animate)) {\n      forEachDefinition(props, animate, target => {\n        for (const name in target) {\n          const memberName = getWillChangeName(name);\n\n          if (memberName) {\n            willChange.add(memberName);\n          }\n        }\n      });\n    }\n\n    if (willChange.size) {\n      values.willChange = Array.from(willChange).join(\",\");\n    }\n  }\n\n  return values;\n}\n\nexport { makeUseVisualState };","map":{"version":3,"sources":["D:/reactportfolio/node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs"],"names":["useContext","isAnimationControls","PresenceContext","resolveVariantFromProps","useConstant","resolveMotionValue","MotionContext","isControllingVariants","isVariantNode","getWillChangeName","makeState","props","context","presenceContext","isStatic","applyWillChange","scrapeMotionValuesFromProps","createRenderState","onMount","state","latestValues","makeLatestValues","renderState","mount","instance","makeUseVisualState","config","make","forEachDefinition","definition","callback","list","Array","isArray","i","length","resolved","transitionEnd","transition","target","shouldApplyWillChange","scrapeMotionValues","_a","values","willChange","Set","style","undefined","motionValues","key","initial","animate","isControllingVariants$1","isVariantNode$1","inherit","isInitialAnimationBlocked","variantToSet","valueTarget","index","name","memberName","add","size","from","join"],"mappings":"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","sourcesContent":["import { useContext } from 'react';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { resolveVariantFromProps } from '../../render/utils/resolve-variants.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { isControllingVariants, isVariantNode } from '../../render/utils/is-controlling-variants.mjs';\nimport { getWillChangeName } from '../../value/use-will-change/get-will-change-name.mjs';\n\nfunction makeState({ applyWillChange = false, scrapeMotionValuesFromProps, createRenderState, onMount, }, props, context, presenceContext, isStatic) {\n    const state = {\n        latestValues: makeLatestValues(props, context, presenceContext, isStatic ? false : applyWillChange, scrapeMotionValuesFromProps),\n        renderState: createRenderState(),\n    };\n    if (onMount) {\n        state.mount = (instance) => onMount(props, instance, state);\n    }\n    return state;\n}\nconst makeUseVisualState = (config) => (props, isStatic) => {\n    const context = useContext(MotionContext);\n    const presenceContext = useContext(PresenceContext);\n    const make = () => makeState(config, props, context, presenceContext, isStatic);\n    return isStatic ? make() : useConstant(make);\n};\nfunction forEachDefinition(props, definition, callback) {\n    const list = Array.isArray(definition) ? definition : [definition];\n    for (let i = 0; i < list.length; i++) {\n        const resolved = resolveVariantFromProps(props, list[i]);\n        if (resolved) {\n            const { transitionEnd, transition, ...target } = resolved;\n            callback(target, transitionEnd);\n        }\n    }\n}\nfunction makeLatestValues(props, context, presenceContext, shouldApplyWillChange, scrapeMotionValues) {\n    var _a;\n    const values = {};\n    const willChange = new Set();\n    const applyWillChange = shouldApplyWillChange && ((_a = props.style) === null || _a === void 0 ? void 0 : _a.willChange) === undefined;\n    const motionValues = scrapeMotionValues(props, {});\n    for (const key in motionValues) {\n        values[key] = resolveMotionValue(motionValues[key]);\n    }\n    let { initial, animate } = props;\n    const isControllingVariants$1 = isControllingVariants(props);\n    const isVariantNode$1 = isVariantNode(props);\n    if (context &&\n        isVariantNode$1 &&\n        !isControllingVariants$1 &&\n        props.inherit !== false) {\n        if (initial === undefined)\n            initial = context.initial;\n        if (animate === undefined)\n            animate = context.animate;\n    }\n    let isInitialAnimationBlocked = presenceContext\n        ? presenceContext.initial === false\n        : false;\n    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n    const variantToSet = isInitialAnimationBlocked ? animate : initial;\n    if (variantToSet &&\n        typeof variantToSet !== \"boolean\" &&\n        !isAnimationControls(variantToSet)) {\n        forEachDefinition(props, variantToSet, (target, transitionEnd) => {\n            for (const key in target) {\n                let valueTarget = target[key];\n                if (Array.isArray(valueTarget)) {\n                    /**\n                     * Take final keyframe if the initial animation is blocked because\n                     * we want to initialise at the end of that blocked animation.\n                     */\n                    const index = isInitialAnimationBlocked\n                        ? valueTarget.length - 1\n                        : 0;\n                    valueTarget = valueTarget[index];\n                }\n                if (valueTarget !== null) {\n                    values[key] = valueTarget;\n                }\n            }\n            for (const key in transitionEnd) {\n                values[key] = transitionEnd[key];\n            }\n        });\n    }\n    // Add animating values to will-change\n    if (applyWillChange) {\n        if (animate && initial !== false && !isAnimationControls(animate)) {\n            forEachDefinition(props, animate, (target) => {\n                for (const name in target) {\n                    const memberName = getWillChangeName(name);\n                    if (memberName) {\n                        willChange.add(memberName);\n                    }\n                }\n            });\n        }\n        if (willChange.size) {\n            values.willChange = Array.from(willChange).join(\",\");\n        }\n    }\n    return values;\n}\n\nexport { makeUseVisualState };\n"]},"metadata":{},"sourceType":"module"}